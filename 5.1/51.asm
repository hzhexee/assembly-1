;==========================================
; ПРОГРАММА ПОДСЧЕТА ЧЕТНЫХ ЧИСЕЛ
;==========================================
; Программа запрашивает 10 натуральных чисел,
; подсчитывает количество четных среди них,
; и выводит результат.
;
; Компиляция и сборка:
;   nasm -f elf32 51.asm -o 51.o
;   ld -m elf_i386 51.o -o 51
;
; Запуск: ./51

section .data
    prompt_msg db "Введите 10 натуральных чисел:", 10
    prompt_len equ $ - prompt_msg
    input_msg db "Введите число "
    input_msg_len equ $ - input_msg
    colon_msg db ": "
    colon_len equ $ - colon_msg
    result_msg db "Количество четных целых чисел: "
    result_len equ $ - result_msg
    error_msg db "Ошибка: введите только числа!", 10
    error_len equ $ - error_msg
    empty_error_msg db "Ошибка: пустой ввод!", 10
    empty_error_len equ $ - empty_error_msg
    newline db 10

section .bss
    array resd 10        ; Массив для хранения 10 целых чисел
    buffer resb 12       ; Буфер для ввода
    num_buffer resb 2    ; Буфер для отображения номера числа
    
section .text
global _start

;==========================================
; ТОЧКА ВХОДА В ПРОГРАММУ
;==========================================
_start:
    ;----------------------------------------
    ; БЛОК ВЫВОДА: Приглашение для ввода
    ; Отображает сообщение с просьбой ввести 10 чисел
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, prompt_msg ; Адрес сообщения
    mov edx, prompt_len ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; БЛОК ИНИЦИАЛИЗАЦИИ: Подготовка к вводу
    ;----------------------------------------
    xor esi, esi        ; Инициализация индекса массива (esi = 0)
    
;==========================================
; ЦИКЛ ВВОДА ЧИСЕЛ
; Запрашивает, считывает и проверяет 10 чисел
;==========================================
input_loop:
    ;----------------------------------------
    ; Подблок: Вывод приглашения для ввода числа
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, input_msg  ; Адрес сообщения "Введите число "
    mov edx, input_msg_len ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Вывод номера текущего числа (esi + 1)
    ;----------------------------------------
    mov eax, esi        ; Копируем индекс в eax
    inc eax             ; Увеличиваем на 1 (человеко-читаемый индекс)
    add eax, '0'        ; Преобразуем в ASCII
    mov [num_buffer], al ; Сохраняем в буфер
    
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, num_buffer ; Адрес буфера с номером
    mov edx, 1          ; Длина - 1 символ
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Вывод двоеточия и пробела
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, colon_msg  ; Адрес сообщения ": "
    mov edx, colon_len  ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Чтение ввода пользователя
    ;----------------------------------------
    mov eax, 3          ; Системный вызов 3 - read
    mov ebx, 0          ; Файловый дескриптор 0 - stdin
    mov ecx, buffer     ; Адрес буфера для ввода
    mov edx, 12         ; Максимальная длина ввода
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Проверка на пустой ввод
    ;----------------------------------------
    cmp eax, 1          ; Сравниваем количество прочитанных байт с 1
    jg check_input      ; Если больше 1, проверяем ввод
    
    ;----------------------------------------
    ; Подблок: Обработка пустого ввода
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, empty_error_msg ; Адрес сообщения об ошибке
    mov edx, empty_error_len ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    jmp input_loop      ; Возврат к началу цикла ввода
    
;==========================================
; БЛОК ПРОВЕРКИ И ПРЕОБРАЗОВАНИЯ ВВОДА
; Преобразует ASCII-строку в число
;==========================================
check_input:
    ;----------------------------------------
    ; Подблок: Инициализация переменных для преобразования
    ;----------------------------------------
    xor ecx, ecx        ; Инициализация результата
    xor edx, edx        ; Инициализация индекса буфера
    mov edi, 0          ; Флаг нахождения цифр (0 = цифры не найдены)
    
    ;----------------------------------------
    ; Подблок: Цикл преобразования ASCII в число
    ;----------------------------------------
convert_loop:
    movzx eax, byte [buffer + edx]  ; Получаем текущий символ
    cmp al, 10          ; Проверка на символ новой строки
    je end_of_input     ; Если найден - конец ввода
    cmp al, '0'         ; Проверка, является ли символ цифрой
    jl invalid_char     ; Если меньше '0', не цифра
    cmp al, '9'         ; Продолжение проверки
    jg invalid_char     ; Если больше '9', не цифра
    
    ;----------------------------------------
    ; Подблок: Обработка корректного символа цифры
    ;----------------------------------------
    mov edi, 1          ; Устанавливаем флаг: цифра найдена
    
    imul ecx, 10        ; Умножаем текущий результат на 10
    sub al, '0'         ; Преобразуем ASCII в число
    movzx eax, al       ; Расширяем до 32 бит с обнулением
    add ecx, eax        ; Добавляем к результату
    
    inc edx             ; Переходим к следующему символу
    jmp convert_loop    ; Продолжаем цикл преобразования
    
    ;----------------------------------------
    ; Подблок: Обработка некорректного символа
    ;----------------------------------------
invalid_char:
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, error_msg  ; Адрес сообщения об ошибке
    mov edx, error_len  ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    jmp input_loop      ; Повторный запрос этого числа
    
    ;----------------------------------------
    ; Подблок: Завершение обработки ввода
    ;----------------------------------------
end_of_input:
    ;----------------------------------------
    ; Подблок: Проверка, найдена ли хотя бы одна цифра
    ;----------------------------------------
    cmp edi, 0          ; Проверяем флаг наличия цифр
    je input_loop       ; Если цифры не найдены, запрашиваем повторно
    
    ;----------------------------------------
    ; Подблок: Сохранение числа в массиве
    ;----------------------------------------
    mov [array + esi*4], ecx  ; Сохраняем преобразованное число в массиве
    inc esi             ; Увеличиваем индекс массива
    
    ;----------------------------------------
    ; Подблок: Проверка завершения ввода всех 10 чисел
    ;----------------------------------------
    cmp esi, 10         ; Сравниваем с 10 (всего чисел)
    jl input_loop       ; Если меньше 10, продолжаем ввод
    
;==========================================
; БЛОК ПОДСЧЕТА ЧЕТНЫХ ЧИСЕЛ
; Перебирает массив и подсчитывает четные числа
;==========================================
    xor esi, esi        ; Сбрасываем индекс массива
    xor edi, edi        ; Инициализация счетчика четных чисел
    
    ;----------------------------------------
    ; Подблок: Цикл подсчета четных чисел
    ;----------------------------------------
count_loop:
    mov eax, [array + esi*4]  ; Загружаем текущее число из массива
    test eax, 1         ; Проверяем младший бит (0 для четных, 1 для нечетных)
    jnz not_even        ; Если бит установлен, число нечетное
    inc edi             ; Увеличиваем счетчик четных чисел
    
not_even:
    inc esi             ; Переходим к следующему числу
    cmp esi, 10         ; Проверяем, достигли ли конца массива
    jl count_loop       ; Если нет, продолжаем цикл
    
;==========================================
; БЛОК ВЫВОДА РЕЗУЛЬТАТА
; Выводит сообщение с количеством четных чисел
;==========================================
    ;----------------------------------------
    ; Подблок: Вывод сообщения о результате
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, result_msg ; Адрес сообщения о результате
    mov edx, result_len ; Длина сообщения
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Преобразование и вывод количества четных чисел
    ;----------------------------------------
    mov eax, edi        ; Помещаем счетчик в eax для преобразования
    call int_to_ascii   ; Вызов подпрограммы преобразования и вывода
    
    ;----------------------------------------
    ; Подблок: Вывод символа новой строки
    ;----------------------------------------
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, newline    ; Адрес символа новой строки
    mov edx, 1          ; Длина - 1 байт
    int 0x80            ; Вызов ядра Linux
    
    ;----------------------------------------
    ; Подблок: Завершение программы
    ;----------------------------------------
    mov eax, 1          ; Системный вызов 1 - exit
    xor ebx, ebx        ; Код возврата 0 (успешное завершение)
    int 0x80            ; Вызов ядра Linux

;==========================================
; ПОДПРОГРАММА ПРЕОБРАЗОВАНИЯ ЧИСЛА В ASCII И ВЫВОДА
; Преобразует число в eax в строку и выводит
;==========================================
int_to_ascii:
    push ebx            ; Сохраняем регистры на стеке
    push ecx
    push edx
    push esi
    
    mov ecx, 10         ; Делитель (основание системы счисления)
    mov esi, buffer + 10 ; Указатель на конец буфера
    mov byte [esi], 0   ; Нуль-терминатор в конце строки
    dec esi             ; Смещаем указатель
    
    ;----------------------------------------
    ; Подблок: Обработка частного случая - нуля
    ;----------------------------------------
    test eax, eax       ; Проверка на ноль
    jnz .convert_loop   ; Если не ноль, переходим к циклу
    mov byte [esi], '0' ; Если ноль, записываем символ '0'
    dec esi             ; Смещаем указатель
    jmp .display        ; Переходим к отображению
    
    ;----------------------------------------
    ; Подблок: Цикл преобразования числа в строку
    ;----------------------------------------
.convert_loop:
    xor edx, edx        ; Очищаем EDX перед делением
    div ecx             ; Делим EAX на 10, остаток в EDX, частное в EAX
    add dl, '0'         ; Преобразуем остаток в ASCII
    mov [esi], dl       ; Сохраняем символ в буфере
    dec esi             ; Смещаем указатель
    
    test eax, eax       ; Проверяем, не стал ли частное нулевым
    jnz .convert_loop   ; Если не нуль, продолжаем цикл
    
    ;----------------------------------------
    ; Подблок: Вывод преобразованного числа
    ;----------------------------------------
.display:
    ; Вычисляем длину числа
    mov edx, buffer + 10 ; Конец буфера
    sub edx, esi        ; Вычитаем адрес начала строки для получения длины
    inc esi             ; Указатель на первую цифру
    
    ; Выводим число
    mov eax, 4          ; Системный вызов 4 - write
    mov ebx, 1          ; Файловый дескриптор 1 - stdout
    mov ecx, esi        ; Указатель на начало строки с числом
    int 0x80            ; Вызов ядра Linux
    
    pop esi             ; Восстанавливаем регистры
    pop edx
    pop ecx
    pop ebx
    ret                 ; Возврат из подпрограммы

section .note.GNU-stack  ; Метка для отключения исполняемого стека
